---
uuid         : ffd53c5d-aded-408d-9b37-d794be93a1ca
order        : 2
author       : huchaomin iisa_peter@163.com
date         : 2025-01-07 15:35:05
lastEditTime : 2025-01-10 15:59:46
lastEditors  : huchaomin iisa_peter@163.com
description  :
---

# Class

## --strictPropertyInitialization

控制类的属性是否必须在构造函数中初始化(true if strict; false otherwise)

```ts
class A {
  name: string // Error: Property 'name' has no initializer and is not definitely assigned in the constructor.
  constructor() {}
}
```

如果想要关闭这个检查，可以使用明确赋值断言运算符 `!` 来告诉 TypeScript 该属性已经被初始化了

```ts
class A {
  name!: string
  constructor() {}
}
```

## 只读属性

```ts
class A {
  // 只读属性：只能在声明时或构造函数中初始化
  readonly name: string = 'world'
  constructor(otherName?: string) {
    if (otherName !== undefined) {
      this.name = otherName // 可以在构造函数中修改
    }
  }
}
```

## 构造函数

- 可重载

    ```ts
    class Point {
      x: number = 0
      y: number = 0

      constructor(x: number, y: number)
      constructor(xy: string)
      constructor(x: number | string, y: number = 0) {}
    }
    ```

- 没有参数类型 `Parameters<>`
- 没有返回类型 `ReturnType<>`

## 方法

方法里面获取类的其他属性或者其他方法，需要使用 `this`

```ts
let x: number = 0

class C {
  x: string = 'hello'

  m() {
    x = 'world' // Type 'string' is not assignable to type 'number'. 指的是外层的 x
  }
}
```

## 访问器属性 `Getters / Setters`

- 如果只有 `getter`，则属性 `readonly`
- 如果 `setter` 的参数类型没有指定，会自动从 `getter` 的返回值类型推断
- `setter` 参数类型不匹配，也可以(from 4.3)

    ```ts
    class Thing {
      _size = 0

      get size(): number {
        return this._size
      }

      set size(value: boolean | number | string) {
        const num = Number(value)
        if (!Number.isFinite(num)) {
          this._size = 0
          return
        }
        this._size = num
      }
    }
    ```

## 索引类型

```ts
class A {
  [s: string]: ((s: string) => boolean) | boolean

  check(s: string) {
    return this[s] as boolean
  }
}
```

## 成员可见性 `public / private / protected`

### public 默认

可以在类的内部和外部访问，包括子类。可以被继承，可以被重写，可以省略 `public` 关键字

### protected

可以在类的内部和子类内部访问，但是不能在外部访问

可以被继承，可以被重写。重写时可以改变可见性，将属性或方法从 `protected` 改为其他，重新暴露出来

```ts
class Greeter {
  public greet() {
    console.log(`Hello, ${this.getName()}`) // ok
  }

  protected getName() {
    return 'hi'
  }
}
class SpecialGreeter extends Greeter {
  public howdy() {
    console.log(`Howdy, ${this.getName()}`) // ok
  }
}
const g = new SpecialGreeter()
g.greet() // ok
g.getName() // error
```

跨层级保护访问(Cross-hierarchy protected access)

```ts
class Base {
  protected x: number = 1
}
class Derived1 extends Base {
  protected x: number = 5
}
class Derived2 extends Base {
  f1(other: Derived2) {
    other.x = 10
  }

  f2(other: Derived1) {
    other.x = 10 // error 属性“x”受保护，只能在类“Derived1”及其子类中访问
  }
}
```

### private
